//     /// Yubikey challenge-response authentication
//     /// Derive the root object id from the username/password pair, and
//     /// mix the Yubikey HMAC response into the encryption key derivation.
//     ///
//     /// On every write the root encryption key will change, and the
//     /// 20-byte challenge is written to the root object header
//     /// unencrypted.
//     YubikeyCR { user: String, password: String },
// }

use crate::{chunks::RawChunkPointer, object::ObjectId, ChunkPointer};
pub use blake3::Hasher;
use ring::aead;
pub use ring::rand::{SecureRandom, SystemRandom};
use secrecy::{ExposeSecret, Zeroize};
use std::{
    ops::{Deref, DerefMut},
    sync::Arc,
};
use thiserror::Error;

mod rawkey;
use rawkey::*;
pub(crate) mod symmetric;
pub use symmetric::UsernamePassword;
pub(crate) mod symmetric08;

#[cfg(feature = "cryptobox")]
pub mod symmetric_cryptobox_storage;

const HEADER_SIZE: usize = 512;
const CRYPTO_DIGEST_SIZE: usize = 32;

pub mod public {
    #[cfg(feature = "cryptobox")]
    pub use super::symmetric_cryptobox_storage as crypto_box;
    pub use super::{rawkey::RawKey, Digest, Hasher, IKeySource, KeySource, UsernamePassword};
}

// TODO: ideally this should be a tuple struct wrapping blake3::Hash,
// implementing Serialize & Deserialize and the rest.
//
// That way we get constant time equality checks for free, which is
// prudent to want, but I'm uncertain about a realistic side-channel
// based on this right now.
/// A cryptographic hash of some data
pub type Digest = [u8; CRYPTO_DIGEST_SIZE];

/// HMAC generated by an AEAD scheme
pub type Tag = [u8; 16];

/// Sealed trait to mark encryption schemes usable in Infinitree.
pub trait IKeySource: 'static + CryptoScheme + Send + Sync {}
impl<T> IKeySource for T where T: 'static + CryptoScheme + Send + Sync {}

/// Key source for all crypto operations.
pub type KeySource = Arc<dyn IKeySource>;

/// A derived key that's directly usable to execute encypt/decrypt operations.
pub(crate) type CryptoOps = Arc<dyn ICryptoOps>;

#[derive(Error, Debug)]
pub enum CryptoError {
    #[error("Parse error: {source}")]
    ParseError {
        #[from]
        source: hex::FromHexError,
    },
    #[error("Key error: {source}")]
    KeyError {
        #[from]
        source: argon2::Error,
    },
    #[error("Fatal error")]
    Fatal,
}
pub type Result<T> = std::result::Result<T, CryptoError>;

impl From<ring::error::Unspecified> for CryptoError {
    fn from(_: ring::error::Unspecified) -> Self {
        CryptoError::Fatal
    }
}

/// A trait that pulls together together all cryptographic
/// operations that must be supported by a scheme.
pub trait CryptoScheme {
    fn root_object_id(&self) -> Result<ObjectId>;
    fn open_root(self: Arc<Self>, header: SealedHeader) -> Result<CleartextHeader>;
    fn seal_root(&self, header: CleartextHeader) -> Result<SealedHeader>;

    fn chunk_key(&self) -> Result<ChunkKey>;
    fn index_key(&self) -> Result<IndexKey>;
    fn storage_key(&self) -> Result<StorageKey> {
        self.chunk_key().map(|ck| StorageKey(ck.0))
    }

    fn expose_convergence_key(&self) -> Option<RawKey>;
}

/// Low level encrypt/decrypt operations using a derivative key.
pub(crate) trait ICryptoOps: Send + Sync {
    fn encrypt_chunk(
        &self,
        object_id: ObjectId,
        offs: u32,
        hash: &Digest,
        data: &mut [u8],
    ) -> ChunkPointer;

    fn decrypt_chunk<'buf>(
        &self,
        target: &'buf mut [u8],
        source: &[u8],
        chunk: &ChunkPointer,
    ) -> &'buf mut [u8];

    /// Provide a hash (or HMAC) of `data`
    fn hash(&self, data: &[u8]) -> Digest;

    /// Return a freely usable and cloneable Hasher. May be keyed.
    fn hasher(&self) -> Hasher;
}

macro_rules! key_type {
    ($name:ident) => {
        #[derive(Clone)]
        pub struct $name(CryptoOps);

        impl $name {
            #[allow(unused)]
            pub(crate) fn new(ops: impl ICryptoOps + 'static) -> Self {
                Self(Arc::new(ops))
            }

            #[allow(unused)]
            pub(crate) fn into_inner(self) -> CryptoOps {
                self.0
            }
        }

        impl ICryptoOps for $name {
            fn encrypt_chunk(
                &self,
                object_id: ObjectId,
                offs: u32,
                hash: &Digest,
                data: &mut [u8],
            ) -> ChunkPointer {
                self.0.encrypt_chunk(object_id, offs, hash, data)
            }

            fn decrypt_chunk<'buf>(
                &self,
                target: &'buf mut [u8],
                source: &[u8],
                chunk: &ChunkPointer,
            ) -> &'buf mut [u8] {
                self.0.decrypt_chunk(target, source, chunk)
            }

            fn hash(&self, data: &[u8]) -> Digest {
                self.0.hash(data)
            }

            fn hasher(&self) -> Hasher {
                self.0.hasher()
            }
        }
    };
}

key_type!(IndexKey);
key_type!(ChunkKey);
key_type!(StorageKey);

#[derive(Clone)]
pub struct CleartextHeader {
    pub(crate) root_ptr: RawChunkPointer,
    pub(crate) key: KeySource,
}

#[derive(PartialEq, Eq, Debug, Clone)]
pub struct SealedHeader([u8; HEADER_SIZE]);
impl From<[u8; HEADER_SIZE]> for SealedHeader {
    fn from(buf: [u8; HEADER_SIZE]) -> Self {
        Self(buf)
    }
}

impl DerefMut for SealedHeader {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl Deref for SealedHeader {
    type Target = [u8];

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl Default for SealedHeader {
    fn default() -> Self {
        Self([0; std::mem::size_of::<Self>()])
    }
}

impl AsRef<[u8]> for SealedHeader {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

impl AsMut<[u8]> for SealedHeader {
    fn as_mut(&mut self) -> &mut [u8] {
        &mut self.0
    }
}

#[inline]
fn get_aead(key: RawKey) -> aead::LessSafeKey {
    let key =
        aead::UnboundKey::new(&aead::CHACHA20_POLY1305, key.expose_secret()).expect("bad key");
    aead::LessSafeKey::new(key)
}

fn derive_argon2(secret: &[u8], salt_raw: &[u8], password: &[u8]) -> Result<RawKey> {
    let salt = blake3::hash(salt_raw);

    let mut result = argon2::hash_raw(
        password,
        salt.as_bytes(),
        &argon2::Config {
            hash_length: CRYPTO_DIGEST_SIZE as u32,
            variant: argon2::Variant::Argon2id,
            secret,
            ..argon2::Config::default()
        },
    )?;

    let mut outbuf = [0; CRYPTO_DIGEST_SIZE];
    outbuf.copy_from_slice(&result);
    result.zeroize();

    Ok(outbuf.into())
}

fn derive_subkey(key: &RawKey, ctx: &str) -> Result<RawKey> {
    let outbuf = blake3::derive_key(ctx, key.expose_secret());
    Ok(outbuf.into())
}

fn generate_key(rand: &impl SecureRandom) -> Result<RawKey> {
    let mut buf = [0; CRYPTO_DIGEST_SIZE];
    rand.fill(&mut buf)?;
    Ok(buf.into())
}
