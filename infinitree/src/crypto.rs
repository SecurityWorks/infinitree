//     /// Yubikey challenge-response authentication
//     /// Derive the root object id from the username/password pair, and
//     /// mix the Yubikey HMAC response into the encryption key derivation.
//     ///
//     /// On every write the root encryption key will change, and the
//     /// 20-byte challenge is written to the root object header
//     /// unencrypted.
//     YubikeyCR { user: String, password: String },
// }

pub use blake3::Hasher;
use ring::aead;
pub use ring::rand::{SecureRandom, SystemRandom};
use secrecy::{ExposeSecret, Zeroize};

mod error;
mod header;
mod ops;
mod rawkey;
mod scheme;
mod symmetric;

use rawkey::*;

pub use error::*;
pub use header::*;
pub use ops::*;
pub use scheme::*;
pub use symmetric::UsernamePassword;
pub mod symmetric08;

#[cfg(feature = "cryptobox")]
pub mod cryptobox_storage_ops;

const CRYPTO_DIGEST_SIZE: usize = 32;

pub mod public {
    #[cfg(feature = "cryptobox")]
    pub use super::cryptobox_storage_ops as crypto_box;
    pub use super::{rawkey::RawKey, Digest, Hasher, IKeySource, KeySource, UsernamePassword};
}

// TODO: ideally this should be a tuple struct wrapping blake3::Hash,
// implementing Serialize & Deserialize and the rest.
//
// That way we get constant time equality checks for free, which is
// prudent to want, but I'm uncertain about a realistic side-channel
// based on this right now.
/// A cryptographic hash of some data
pub type Digest = [u8; CRYPTO_DIGEST_SIZE];

/// HMAC generated by an AEAD scheme
pub type Tag = [u8; 16];

#[inline]
fn get_aead(key: RawKey) -> aead::LessSafeKey {
    let key =
        aead::UnboundKey::new(&aead::CHACHA20_POLY1305, key.expose_secret()).expect("bad key");
    aead::LessSafeKey::new(key)
}

fn derive_argon2(secret: &[u8], salt_raw: &[u8], password: &[u8]) -> Result<RawKey> {
    let salt = blake3::hash(salt_raw);

    let mut result = argon2::hash_raw(
        password,
        salt.as_bytes(),
        &argon2::Config {
            hash_length: CRYPTO_DIGEST_SIZE as u32,
            variant: argon2::Variant::Argon2id,
            secret,
            ..argon2::Config::default()
        },
    )?;

    let mut outbuf = [0; CRYPTO_DIGEST_SIZE];
    outbuf.copy_from_slice(&result);
    result.zeroize();

    Ok(outbuf.into())
}

fn derive_subkey(key: &RawKey, ctx: &str) -> Result<RawKey> {
    let outbuf = blake3::derive_key(ctx, key.expose_secret());
    Ok(outbuf.into())
}

fn generate_key(rand: &impl SecureRandom) -> Result<RawKey> {
    let mut buf = [0; CRYPTO_DIGEST_SIZE];
    rand.fill(&mut buf)?;
    Ok(buf.into())
}
